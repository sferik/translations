Garden City Ruby 2014 - Yogi Kulkarni - Lessons Learnt Building India's E-Commerce Supply Chain in Ruby

This talk is about a specific project that we did at Flipkart

so just to give people, foreigners here, a bit of context of Flipkart 

it's sort of like the Amazon of India

and they are the largest e-commerce store in India

we, so yeah, let me keep the numbers for later

so, in 2011 around about in December

there was the, we had a kind of a moment where 

we realized that our supply chain was not going to be able to scale

we were having very, very serious problems

with actually having things, with things, 

actually building new features

it was going very slow

the number of requests hitting our website

were just going through the roof and

and we were not able to keep up

so at that point there was a

so let me just actually talk about what the system looked like

so, this was Version 2 of the supply chain at Flipkart

Version 1 which was kind of written in 2007

was written by our founder, Sachin and Binny themselves in PHP

so this was Version 2, which was written in about 2010

it was Open Source ERP system called Opentaps

which we had extended extensively

it was basically a single monolithic application

it had all these modules for the management, warehousing, so on and so forth

and they all came out of a single JVM

connected to a single database

and that was just horrible

right

the problem was that

each module as we were extending it

the developers didn't actually bother

to kind of think about

should we be accessing this data

this table, should we be crediting it or not

they would just go and make joins across tables

just to solve the problem, get the feature out

right

you're probably familiar with that

so horrible coupling

and we spent about a month trying to see if we can

call up (?? 00:02:22,40)

each piece from the system

and kind of start picking out services

and we couldn't do it

it was just impossible

so, at that point we took a hard, hard decision that

you know, let's actually rewrite

and this was something which was completely against

my past works OR Flipkart works (?? 00:02:35,74)

philosophy of, you know, let's re-factor incrementally

and go slowly and let's have the system running and then

kind of migrate, but

we took the score

and in two-thousand-and, I think it was 2011, in December

we started the project

where, so this was

sort of a 

bed OR bet (?? 00:02:54,30)

the company project for Flipkart

it was so critical at that point that

Sachin, he was the founder, actually came and sat with the team

so we basically 

called up (?? 00:03:02,75)

a team of initially ten people and then

that increased to about thirty developers

and he moved us, moved that team out

to a separate office

which was basically a house

in Banglore, which was the place where

Flipkart was born

and that was, got turned into a 

skunk (?? 00:03:17,65)

works start-up project within Flipkart

where this team worked

and complete isolation

no interviews, no meetings, nothing

this team was only here to build out this system in seven months

because the next milestone was the Diwali

so the Diwali is the time when

we do the most sales in the year

and that was in October of 2012

so we had about seven months to replace

an entire supply chain system

with a new system built from grounds up

get it in production, make sure it's working

and it's scaling right

so get to, probably do it by August

and give ourselves time till August to kind of do that

so yeah, we start up on this project and

the idea was to 

break up each of these modules into

services and I think Chad's talk

really set up the context beautifully for the start

because a lot of the ideas and processes

that he mentioned is stuff that 

we tried to kind of

work on and kind of implement in the system

so, some of the things he wanted to do was

I think it was nice because

it's all small pieces loosely joined

which I came across around that time

I think that beautifully summarizes what

we want to get to

right

each service doing one small thing

so you break down

the warehouse module into a separate service

order management into a separate service

accounting and so on and so forth

we didn't want to go down

micro-services architecture way

I'd worked with Fred George earlier and

I'd gone down, I'd seen of the down sides

of it and I didn't actually have a clear idea of

how to work around those downsides at that point in time

so I was kind of wary about micro-services at that point

and I would love to actually hear other peoples' thoughts

on how that's working out

but anyway, so we all took on our separate services

each doing one thing and doing one thing well

and each service would have its own database

and nobody could access it except the servers

right

you could just access it through an HTTP JSON API

and you will never touch my data

right

my private parts are private

so this is what we ended up with

probably not going to read the thing so I'm gonna read it out to you

so we end up with about twenty-five services

this is a sub-set of the services we actually built

you have all the management service

then the fulfillment orchestration service

which talks to warehousing service

and fulfillment, which in turn talks to supplier

and the whole logistics subsystems 

and you have accounting services

document services

and then you have a bunch of

infrastructure services including this piece at the bottom

which was a messaging system that we ended up building

called Resbus, which I talk a little bit about

which kind of addressed the problem of cross-service transaction integrity

so in this picture the Ruby services were basic- so

each service, for example, the order management service

the blue pieces were written in Padrino or Sinatra

[mumbling]

so these are in Padrino and

00:06:38.12

and added

OR

and also

OR

the add-on

00:06:37.61

JRuby when we went live

we eventually migrated those to MRI

but, and I'm going to be clear about why

so these were the Padrino services

and then the UI pieces where required were written in Ruby on Rails

running on MRI

we also had some infrastructure services running on Ruby

for example the single sign-on service was

and used (?? 00:06:57,7) CAS and used RubyCAS

we built our rule-based access system again in Ruby

and a bunch of other pieces

right

so essentially we went from monolithic single system

to twenty-five services

right

and this was a massive change

and this, so each, there were total about seven teams

which worked on this project

owning one or two services

each team had between four and six developers

yeah, so that's to just set the context

about where we were

so, when we started the project in two thousand and, early

2011, we were doing about

the old system was doing, the system was doing about

20,000 orders a day

30,000 shipments a day

roughly around that order

and this new system has now survived 

two Diwali workloads

which includes the latest Diwali which was in 2013

we did, I think 100,000 orders and 150,000 shipments

and it's working pretty well

so, at the time when we were making this decision

we were kind of selecting the technology stack

and we, the big question was, you know, what tech stack to use

so Flipkart traditionally had a lot

so we, Opentabs given the Java stack

so most developers were very, very comfortable with Java

so the thought of actually introducing a new language

a new ecosystem

was, people were kind of wary about that

also there were concerns about performance

but, I knew from my experience in the past that

performance is not a language issue

it's an architecture design issue fundamentally

right

and there  are differences in technologies and languages

and I talk a little bit more about that in detail

but performance I'm not too worried about

so why Ruby then?

so there's a, the obvious reason is

speed of development

right

we had a short, a very, very tight deadline

to detail the

?? (00:09:13,5)

system in seven months

we wanted to move fast

right 

so that's obviously one benefit

the other reason was

I think this idea of small pieces loosely joined

is really powerful

small code pieces are inherently easier to debug

right

like even if you have the best tools and you have a large Jar system

it's hard to work even if things are great for filers

great modeling tools

it's still hard when you are dealing

with 100,000 line code base

you, it's just far more complex than dealing with

something that is maybe 10,000 lines

or maybe 5,000 lines of code right

and that code compression that Ruby allows

is actually really powerful

also I think in the Ruby world

Ruby's secret weapon is not Rails

I think to me, Ruby's secret weapon is activerecord

especially for business applications

there's, I just love it as a new item tool

and it has its problems

especially in the enterprise space when

you are dealing with fairly complex logic

a lot of cases where

so because it lacks what's called an identity map

you can have situations where if you're not traversing from

parent to object, to a child object, and back

to the parent object, you end up with two references to the

two instances of the parent object

right

and that's kind of bad

tools like Hibernate in the Java world actually solve this beautifully

so yeah, so it has its glitches

but still, as a tool to write business applications

I think there's, it's fairly amazing

so we want to use the power of activerecord

we want to have small systems

which is why we built our services

back-end services which were the HTTP JSON ones

only in Sinatra

so Padrino was just a pin wrapped around it

so it's Sinatra talking to its own database

OK, so I'm gonna kind of try and focus a lot more on the lessons learned

so I'm kind of going to be jumping topics a bit 

and it might be a bit of discontinuity so

you'll excuse that

but I want to kind of get the real key insights that we had on the project out

than worry about a kind of a consistent flow

so JRuby

right

let me start it off good

so JRuby is incredible

it's an amazing piece of technology, great community

you get the power of the JVM which is just amazing

and specifically within the JVM what you want is

it's garbage collector

and the just-in-time compilation

very cohesive (?? 00:11:46,7)

those two are just amazing

I'll share some numbers about how those two things actually make a difference

but that's a good part of JRuby

right

amazing ecosystem

you get all the tools that are in the Jar would just work

not just work, but they work OK with, in JRuby context

but still you get a lot of tools like this that can be used, et cetera

the bad

so what's bad about JRuby?

one thing that gets talked about a lot is its slow start-up time

and it is a massive, massive issue

typically, when you're kind of coding

particularly when you're testing, you want

to have a very quick cycle of going from test to code to test

and back and forth

but that's hard to do with JRuby

and there are other things you can do

you can use things like ?? (00:12:43,4)

is almost like using Nailgun, for example, or Spork

(00:12:46,2) ?? (00:12:47,8)

and then connect to it and run tests against it

so all that is fine but

it's still very sluggish to work with

right

so you end up having to do a

to kind of jump through hoops to work good on that problem

for example

we ended up writing

so all our development was in CRuby

so tests run very fast, specs run fast, scripts run fast

but you deploy to JRuby

but even then, even for CI

and for deployment, you end up isolating

kind of scripts which were launched in CRuby

but they were in turn just launched JRuby just for the pieces which actually required JRuby

so you had to kind of do a bunch of these things

just kind of, not great

so but all this you could kind of live with, right

there's one thing about JRuby which surprisingly isn't talked about so much

which I think is fundamentally a deal breaker

and that's its test suite

it's actually 

it's not actually a JRuby problem

I just think the Ruby world is just not ready to work on truly multi-threaded Ruby interpreter

right, which is without a global interpreter lock

and this manifested in horrible, horrible bugs for us

so when you start working at scale

you know you're getting tons of requests

in the system

so these problems typically don't manifest when you're running a small service

and you know JRuby works fine for that

all good

but you will run into cases where

some library was not written with thread safety in mind

and that will just kill you

and it is virtually impossible to debug

so the beefiest problems with Padrino

where the actual app wouldn't get initialized

and it was just horrible bring it out

and the problem turned out to be something

in HTTP router, which is a Gem used for actual route of creation

and there's no fix for that

it's been over a year and a half

and it's still not been fixed

we actually put in a patch to Padrino to actually work 

(00:14:53)
