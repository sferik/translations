1
00:00:00,401 --> 00:00:05,060
(energetic music)

2
00:00:14,815 --> 00:00:17,951
Jim: Good morning. You excited
to be here for RubyConf?

3
00:00:18,218 --> 00:00:20,387
(cheers)

4
00:00:21,289 --> 00:00:23,891
Excellent, excellent.
I'm glad to be here too.

5
00:00:24,449 --> 00:00:27,861
We're going to be talking about
the y combinator this morning.

6
00:00:27,861 --> 00:00:31,650
How many people here are very
familiar with the y combinator?

7
00:00:33,100 --> 00:00:35,335
Just a very few people, very good.

8
00:00:35,335 --> 00:00:37,404
That means I can say
anything I want to about it.

9
00:00:39,984 --> 00:00:44,100
I've got extensive speaking
experience, and I've learned

10
00:00:44,100 --> 00:00:47,916
a couple rules, particularly
about keynote talks.

11
00:00:47,916 --> 00:00:49,483
Keynotes are just a little bit different

12
00:00:49,483 --> 00:00:51,651
than your regular, everyday session.

13
00:00:51,852 --> 00:00:57,191
For one thing, keynotes tend
to be a little less technical.

14
00:00:57,257 --> 00:01:00,494
You want to inspire the
folks that are attending,

15
00:01:00,494 --> 00:01:02,329
you want to motivate them,

16
00:01:02,329 --> 00:01:05,465
so you tend to stay away from
the highly technical talks.

17
00:01:05,766 --> 00:01:09,536
I am glad to say this talk
will be highly technical.

18
00:01:12,048 --> 00:01:14,342
If you're going to be really
technical then maybe you

19
00:01:14,342 --> 00:01:18,546
should at least make what
you're talking about relevant

20
00:01:18,546 --> 00:01:22,149
to the day-to-day life of
the programmers, so they can

21
00:01:22,149 --> 00:01:26,858
take home something that
they can use in their work.

22
00:01:26,858 --> 00:01:28,789
You may use it tomorrow.

23
00:01:28,955 --> 00:01:31,892
I am glad to say that this
talk is extremely pointless.

24
00:01:34,264 --> 00:01:37,864
There's very little in this
that you can take home and use.

25
00:01:39,400 --> 00:01:42,350
If you're not going to be relevant,

26
00:01:43,860 --> 00:01:46,507
and you're going to be highly technical,

27
00:01:46,507 --> 00:01:48,676
then at least if you're
doing code examples,

28
00:01:48,676 --> 00:01:52,412
make it examples of good
code, good coding practices,

29
00:01:52,412 --> 00:01:55,887
so you're instilling those
good practices in the people,

30
00:01:55,887 --> 00:01:57,384
so that when they get home at least

31
00:01:57,384 --> 00:01:59,520
they got something out of that.

32
00:01:59,520 --> 00:02:00,987
I am also happy to say this will be the

33
00:02:00,987 --> 00:02:04,491
worst Ruby code you've probably ever seen.

34
00:02:05,859 --> 00:02:08,195
So what are the redeeming
factors of this talk?

35
00:02:08,195 --> 00:02:10,365
Well all I can say, it's going
to be a little bit of fun.

36
00:02:10,831 --> 00:02:15,235
(applause)

37
00:02:15,569 --> 00:02:17,103
The first thing I need
to do is I'm going to

38
00:02:17,103 --> 00:02:19,873
need a little bit of
audience participation.

39
00:02:20,106 --> 00:02:23,877
I need someone who has
a calculator that can

40
00:02:23,877 --> 00:02:27,914
calculate the cosine
of an angle in radians.

41
00:02:28,150 --> 00:02:32,318
Do I have any people who might
have a calculator to do that?

42
00:02:33,120 --> 00:02:35,321
Anybody, any volunteers here?

43
00:02:36,123 --> 00:02:38,425
Way in the back there, yes, yes!

44
00:02:39,393 --> 00:02:43,240
You got a calculator in there?
Go ahead and pull it out.

45
00:02:48,302 --> 00:02:50,737
Oh good, he's coming up
here. Excellent, excellent.

46
00:02:56,224 --> 00:02:58,678
I want you to type in the number zero.

47
00:02:59,790 --> 00:03:02,782
Make sure you are in
radians mode for cosine.

48
00:03:03,750 --> 00:03:05,718
Then hit the cosine button.

49
00:03:06,701 --> 00:03:08,188
You got an answer?

50
00:03:08,188 --> 00:03:10,808
Audience Member: I do.
Jim: Okay, hit the cosine button again.

51
00:03:12,659 --> 00:03:14,270
Hit it again.

52
00:03:15,128 --> 00:03:16,797
Hit it again.

53
00:03:17,231 --> 00:03:19,320
Keep doing that until I get back to you.

54
00:03:19,320 --> 00:03:21,434
(laughter)

55
00:03:23,870 --> 00:03:27,540
The topic of my talk is
called effectively computable,

56
00:03:27,540 --> 00:03:29,676
that's what we're going
to be talking about.

57
00:03:29,809 --> 00:03:32,246
This was a topic that was explored

58
00:03:32,246 --> 00:03:34,447
by a fellow named Alan Turing.

59
00:03:34,447 --> 00:03:35,804
You may have heard of Turing,

60
00:03:35,804 --> 00:03:38,284
he invented something
called a Turing machine.

61
00:03:38,886 --> 00:03:41,288
A Turing machine is a simple machine that

62
00:03:41,288 --> 00:03:43,823
has an infinite tape with cells on it.

63
00:03:43,990 --> 00:03:47,160
Those cells, you could write
characters into those cells,

64
00:03:47,228 --> 00:03:50,297
and you can then read back the cell,

65
00:03:50,297 --> 00:03:52,832
you can erase the cell and
write a new character into it,

66
00:03:52,832 --> 00:03:55,268
and you can move the tape
one position at a time.

67
00:03:55,268 --> 00:03:57,971
All those functions are
controlled by a very, very, very

68
00:03:57,971 --> 00:04:02,175
simple-minded program that
sits and can say if the current

69
00:04:02,175 --> 00:04:05,745
cell is a one then shift left
and go to this, you know.

70
00:04:06,160 --> 00:04:08,348
Very simple-minded programming.

71
00:04:08,448 --> 00:04:12,785
In fact, here is an animation
of a turing machine.

72
00:04:12,919 --> 00:04:15,288
I so want one of these devices.

73
00:04:22,743 --> 00:04:27,600
If you're watching here, there
is a camera here with a light,

74
00:04:27,600 --> 00:04:30,370
and you can see it's reading
these characters right there.

75
00:04:30,636 --> 00:04:33,600
It's reading the one,
it's reading that one.

76
00:04:33,600 --> 00:04:36,610
There's an eraser head over
here, that he can erase

77
00:04:36,610 --> 00:04:39,512
that one and then write
a zero in place of it.

78
00:04:39,546 --> 00:04:43,316
This is a counter. He initialized
it with the number 11.

79
00:04:45,890 --> 00:04:47,521
Now we're up to 12.

80
00:04:50,524 --> 00:04:52,426
Now we're up to 13.

81
00:04:54,929 --> 00:04:56,697
It's a very simple program
that just reads the

82
00:04:56,697 --> 00:04:59,366
character under the
camera and decides whether

83
00:04:59,366 --> 00:05:01,569
to change it to a one
or a zero, and carries

84
00:05:01,569 --> 00:05:04,538
the one over, and it's
doing binary counting.

85
00:05:04,671 --> 00:05:07,474
We are up to, that looks like 14 now.

86
00:05:08,008 --> 00:05:09,609
Now we're up to 15.

87
00:05:18,510 --> 00:05:20,153
Now we're carrying the one all the way up.

88
00:05:21,793 --> 00:05:23,656
Erases the one.

89
00:05:25,826 --> 00:05:27,294
And now it's running
real-time. It was actually

90
00:05:27,294 --> 00:05:29,529
running in fast speed before.
This is real-time now.

91
00:05:29,963 --> 00:05:32,598
Sees a zero, reads a zero.

92
00:05:33,266 --> 00:05:35,236
Reads a one, erases it.

93
00:05:36,369 --> 00:05:38,538
Writes in the zero, it's
going to carry the one.

94
00:05:38,538 --> 00:05:40,173
It reads over until it finds a

95
00:05:40,173 --> 00:05:42,430
blank space and then it carries

96
00:05:42,430 --> 00:05:45,178
the one over to the blank
space, and the program's done.

97
00:05:46,120 --> 00:05:47,881
That is a Turing machine.

98
00:05:49,916 --> 00:05:52,561
(applause)

99
00:05:52,561 --> 00:05:54,855
Can somebody build me one
of those? That's awesome.

100
00:05:56,275 --> 00:05:59,774
Turing said that anything
that is effectively

101
00:05:59,774 --> 00:06:03,263
computable can be computed by this really

102
00:06:03,263 --> 00:06:06,299
dirt-simple machine, this Turing machine.

103
00:06:06,434 --> 00:06:08,735
What he meant by anything
that can be computed,

104
00:06:08,735 --> 00:06:10,905
he's generally talking about mathematical

105
00:06:10,905 --> 00:06:14,107
functions or logic
problems, things like that.

106
00:06:14,140 --> 00:06:16,760
Anything that you can
write an algorithm to do,

107
00:06:16,760 --> 00:06:18,746
you can write that algorithm
in a Turing machine

108
00:06:18,746 --> 00:06:21,148
and have your Turing
machine calculate it out.

109
00:06:21,815 --> 00:06:25,099
That's kind of mind-boggling.
And look at the date on this.

110
00:06:25,099 --> 00:06:28,755
This is in the 1936, 1937 time frame.

111
00:06:28,922 --> 00:06:31,692
The very first programmable computer was

112
00:06:31,692 --> 00:06:34,861
probably invented in
Germany in around 1936.

113
00:06:34,961 --> 00:06:38,899
So he's doing all this
research in his head, on paper.

114
00:06:39,990 --> 00:06:41,167
There's no computers that he's using

115
00:06:41,167 --> 00:06:43,636
to do any of this stuff with at all.

116
00:06:43,937 --> 00:06:47,574
This is actually pre-computer
work that's being done.

117
00:06:48,975 --> 00:06:50,610
Around the same time frame there's

118
00:06:50,610 --> 00:06:53,613
this fellow named Alonzo Church.

119
00:06:54,810 --> 00:06:57,851
Church designed something
called lambda calculus,

120
00:06:57,851 --> 00:06:59,687
you might have heard of that.

121
00:06:59,687 --> 00:07:02,489
Lambda calculus is a way
of calculating things.

122
00:07:02,689 --> 00:07:05,558
It consists of the lambda character here,

123
00:07:05,558 --> 00:07:07,295
which introduces a function.

124
00:07:07,295 --> 00:07:09,229
After the lambda character will

125
00:07:09,229 --> 00:07:11,631
become a variable name, here x.

126
00:07:11,807 --> 00:07:13,735
After the x is a dot that separates the

127
00:07:13,735 --> 00:07:16,436
variable name from the
body of the function.

128
00:07:16,436 --> 00:07:19,207
In this case the body of
the function is another x.

129
00:07:19,239 --> 00:07:21,776
This is, in essence,
the identity function.

130
00:07:21,776 --> 00:07:23,478
You pass this function in any value

131
00:07:23,478 --> 00:07:25,979
and it will return that very same value.

132
00:07:25,979 --> 00:07:30,116
This is a very, very, very simple
function in lambda calculus.

133
00:07:30,383 --> 00:07:34,687
This is all there is to lambda calculus.

134
00:07:37,162 --> 00:07:40,727
There are no strings,
there are no integers,

135
00:07:40,727 --> 00:07:43,463
there are no floating point
numbers in lambda calculus.

136
00:07:43,530 --> 00:07:47,601
There are only functions and
the calling of those functions.

137
00:07:47,935 --> 00:07:50,737
So how do we represent
interesting things in it?

138
00:07:50,737 --> 00:07:52,305
Here's one particular scheme you

139
00:07:52,305 --> 00:07:54,274
might use to represent some numbers.

140
00:07:54,274 --> 00:07:56,476
Let's look at the number one over there.

141
00:07:56,576 --> 00:07:59,379
You see it's a lambda function
that takes an argument f and

142
00:07:59,379 --> 00:08:02,815
it returns a lambda function
that takes an argument x.

143
00:08:03,160 --> 00:08:05,886
In essence you can think
of this, in my mind I group

144
00:08:05,886 --> 00:08:09,222
this together as a single
function taking two arguments.

145
00:08:10,876 --> 00:08:13,193
It takes the function f and applies it,

146
00:08:13,193 --> 00:08:16,663
it calls it, given the value x.

147
00:08:16,663 --> 00:08:20,567
It calls the function f
passing in an x one time.

148
00:08:20,634 --> 00:08:23,169
That represents the number one.

149
00:08:23,369 --> 00:08:25,974
The number two is represented
by a two argument function

150
00:08:25,974 --> 00:08:29,410
that takes the function f and
a value x, and it calls the

151
00:08:29,410 --> 00:08:34,113
function f twice on the function
f, so that represents a two.

152
00:08:34,181 --> 00:08:38,619
Zero calls the function f
zero times on the value,

153
00:08:38,651 --> 00:08:40,286
and this is how we represent numbers.

154
00:08:40,286 --> 00:08:43,690
We can represent any
number you want to just by

155
00:08:43,690 --> 00:08:47,761
applying the function f
multiple times to that value.

156
00:08:47,794 --> 00:08:50,960
This is called a Church numeral.

157
00:08:50,960 --> 00:08:52,732
This is how you represent
numbers in lambda calculus.

158
00:08:53,367 --> 00:08:55,469
How might you represent true and false?

159
00:08:55,655 --> 00:08:56,870
At the bottom of the screen you can

160
00:08:56,870 --> 00:08:59,238
see true is a function of two variables.

161
00:09:00,105 --> 00:09:01,941
True returns the first variable.

162
00:09:01,941 --> 00:09:04,212
False is also a function of two variables

163
00:09:04,212 --> 00:09:06,680
and returns the second argument to that.

164
00:09:08,069 --> 00:09:09,783
True is kind of like an if-then-else,

165
00:09:09,783 --> 00:09:11,820
it returns the then part, and the false is

166
00:09:11,820 --> 00:09:14,253
an if-then-else that
returns the false part.

167
00:09:14,455 --> 00:09:17,590
That's how you represent true
and false in lambda calculus.

168
00:09:19,126 --> 00:09:21,327
Keys to lambda calculus are that

169
00:09:21,327 --> 00:09:23,363
functions are the only data type.

170
00:09:23,363 --> 00:09:24,931
No integers, no strings,
no floating point,

171
00:09:24,931 --> 00:09:28,168
no arrays, nothing else but functions.

172
00:09:28,401 --> 00:09:31,471
Lambda binding is the only way you can

173
00:09:31,471 --> 00:09:35,142
associate a value with a variable name.

174
00:09:35,376 --> 00:09:38,878
You do lambda binding by
calling the function on a value,

175
00:09:38,878 --> 00:09:42,248
and that will bind the
value to the variable,

176
00:09:42,909 --> 00:09:44,984
the argument in the
function, and then you expand

177
00:09:44,984 --> 00:09:47,587
the body of the function
using that substitution.

178
00:09:47,955 --> 00:09:50,723
All calculation in lambda calculus happens

179
00:09:50,723 --> 00:09:53,827
by a process called beta reduction.

180
00:09:53,827 --> 00:09:56,196
There's also another process
called alpha reduction,

181
00:09:56,196 --> 00:09:58,999
but the important one
is the beta reduction.

182
00:10:00,293 --> 00:10:02,769
Let's give you an example
of beta reduction.

183
00:10:02,769 --> 00:10:07,600
Here we have the lambda
calculus representations of true

184
00:10:08,144 --> 00:10:10,544
and it's being called on
the number one, and then the

185
00:10:10,544 --> 00:10:13,813
result of that is being
passed in the number zero,

186
00:10:13,813 --> 00:10:16,182
and we're passing in the
lambda calculus versions.

187
00:10:16,182 --> 00:10:19,452
To do a beta reduction you
take the function in question.

188
00:10:19,786 --> 00:10:22,322
You identify the variable x, and you

189
00:10:22,322 --> 00:10:25,424
expand the body of the function out.

190
00:10:25,992 --> 00:10:29,162
Then you replace anywhere in
the body where there is an x,

191
00:10:29,162 --> 00:10:31,798
the variable, you replace
that with the argument.

192
00:10:31,798 --> 00:10:34,901
The argument one gets
substituted in for the x,

193
00:10:35,200 --> 00:10:37,837
and this is the final result
of that beta expansion.

194
00:10:38,171 --> 00:10:40,740
Let's do one more beta expansion,

195
00:10:40,740 --> 00:10:43,420
expanding the result of
this with the argument zero.

196
00:10:43,420 --> 00:10:46,113
We identify the argument
of the function is y.

197
00:10:47,528 --> 00:10:50,216
We expand the body of
the function out and we

198
00:10:50,216 --> 00:10:52,952
brought it down below,
that's the red circle there.

199
00:10:52,952 --> 00:10:57,257
Then we substitute in zero for
the value y in the body, and

200
00:10:57,257 --> 00:11:01,761
happens to be no value y in the
body so we're done, that's it.

201
00:11:01,761 --> 00:11:04,364
If you pass true a one and a zero,

202
00:11:04,364 --> 00:11:07,667
it's going to return a
one. That makes sense.

203
00:11:08,501 --> 00:11:10,836
True is a function that
returns the first argument.

204
00:11:11,904 --> 00:11:14,941
That's beta reduction in lambda
calculus, and you can see

205
00:11:14,941 --> 00:11:18,911
that lambda calculus is nothing
more than macro expansion.

206
00:11:19,613 --> 00:11:22,915
It's merely text substitution
that you take the

207
00:11:22,915 --> 00:11:25,918
arguments and you substitute
them in and expand them out.

208
00:11:25,918 --> 00:11:29,188
This is really, really
simple macro expansion here.

209
00:11:29,789 --> 00:11:32,892
Church said, "Anything that
can be effectively computable

210
00:11:32,892 --> 00:11:36,280
"can be computed via lambda calculus."

211
00:11:36,416 --> 00:11:39,232
I hope you're scratching your
head here because as I just said,

212
00:11:39,232 --> 00:11:43,236
lambda calculus is nothing more
than simple macro expansion.

213
00:11:43,569 --> 00:11:45,505
But Church actually made his thesis,

214
00:11:45,505 --> 00:11:51,144
he beat Turing to the punch,
he said this around 1933, 1935,

215
00:11:51,144 --> 00:11:53,579
he wrote a couple papers on this topic,

216
00:11:53,579 --> 00:11:55,182
so he beat Turing by a couple years.

217
00:11:55,182 --> 00:11:56,850
In fact when Turing's paper came out,

218
00:11:56,850 --> 00:11:59,986
and Turing said a Turing
machine can calculate

219
00:11:59,986 --> 00:12:02,321
anything that's effectively
computable, there was

220
00:12:02,321 --> 00:12:04,825
a long debate in the
mathematical circles whether the

221
00:12:04,825 --> 00:12:08,482
two sets of things that
were effectively computable

222
00:12:08,482 --> 00:12:10,697
were actually the same thing or not.

223
00:12:10,697 --> 00:12:14,660
Generally today we agree
that lambda calculus and

224
00:12:14,660 --> 00:12:15,870
Turing machines, and then
there was a third thing

225
00:12:15,870 --> 00:12:18,871
called general recursion
that was also done.

226
00:12:18,872 --> 00:12:21,774
All of those things are Turing complete.

227
00:12:21,774 --> 00:12:24,277
In other words they can all
calculate everything that can be

228
00:12:24,277 --> 00:12:29,160
calculated, can be calculated
in any of those three systems,

229
00:12:29,820 --> 00:12:32,919
lambda calculus, general
recursion or Turing machines.

230
00:12:33,587 --> 00:12:36,956
We see the influences of
lambda calculus today.

231
00:12:37,124 --> 00:12:39,492
If you look at our language
Lisp has lambdas all over it.

232
00:12:39,492 --> 00:12:42,295
Clojure has an fn anonymous function

233
00:12:42,295 --> 00:12:44,831
that is essentially a lambda.

234
00:12:45,640 --> 00:12:46,699
In Ruby we like lambdas so much we

235
00:12:46,699 --> 00:12:48,901
have several ways of doing them.

236
00:12:50,837 --> 00:12:55,275
CoffeeScript has a very concise
way of representing lambdas,

237
00:12:55,275 --> 00:12:59,880
and Javascript itself has lambdas as well.

238
00:12:59,880 --> 00:13:03,216
Anonymous functions are nothing
more than lambdas or closures.

239
00:13:03,517 --> 00:13:05,218
If you went to Pat's talk yesterday on

240
00:13:05,218 --> 00:13:07,386
block you learned what a closure was.

241
00:13:07,386 --> 00:13:10,290
This is all these things
are, closures or lambdas.

242
00:13:12,836 --> 00:13:16,395
Let's put that aside and remember
that even though it seems

243
00:13:16,395 --> 00:13:20,600
hard for us to believe, lambda
calculus is Turing complete.

244
00:13:20,600 --> 00:13:22,502
There's a problem with
that that we'll get to in

245
00:13:22,502 --> 00:13:25,205
a little bit but first I
want to return to the topic.

246
00:13:25,205 --> 00:13:27,473
Where's my volunteer?

247
00:13:29,009 --> 00:13:30,810
What number did you get after

248
00:13:30,810 --> 00:13:32,813
pressing cosine many, many times?

249
00:13:33,146 --> 00:13:35,881
Audience: 0.739085

250
00:13:38,702 --> 00:13:42,631
Jim: Very good. Thank you, thank you

251
00:13:42,631 --> 00:13:44,724
very much, I really appreciate that.

252
00:13:44,724 --> 00:13:48,989
(applause)

253
00:13:49,529 --> 00:13:52,466
Turns out, if you take the
cosine of zero that's a one.

254
00:13:52,466 --> 00:13:56,736
If you take the cosine of one
that is about .54 blah blah blah.

255
00:13:56,736 --> 00:13:59,373
If you keep doing that over
and over again, and if you

256
00:13:59,373 --> 00:14:04,777
do that about 89 or 90
times, depends on how precise

257
00:14:04,777 --> 00:14:08,781
your floating point math
is, you'll start zeroing

258
00:14:08,781 --> 00:14:13,786
in on a number that is
.7390851 blah blah blah blah.

259
00:14:14,880 --> 00:14:17,324
This is a fixpoint of cosine.

260
00:14:17,324 --> 00:14:21,594
That means if I give that
.73 number to the cosine

261
00:14:21,594 --> 00:14:24,564
function in radians it
will return that exact

262
00:14:24,564 --> 00:14:27,990
same number, and we
have converged on this.

263
00:14:27,990 --> 00:14:31,504
A fixpoint is nothing more than a value

264
00:14:31,504 --> 00:14:33,540
you give to a function
and if that functions

265
00:14:33,540 --> 00:14:36,543
returns the same value
then that is a fixpoint.

266
00:14:36,843 --> 00:14:39,378
It turns out lots of
functions have fixpoints.

267
00:14:40,112 --> 00:14:43,282
Here's the formal definition of
fixpoint so you could see it.

268
00:14:43,416 --> 00:14:45,418
Give x to a function, it returns x,

269
00:14:45,418 --> 00:14:47,853
x will be a fixpoint of that function.

270
00:14:49,063 --> 00:14:52,392
For cosine, cosine is a fun
fixpoint because you get to

271
00:14:52,392 --> 00:14:55,561
zero in on it just by hitting
that cosine button a lot.

272
00:14:55,561 --> 00:14:58,431
Other functions have actually
much simpler fixpoints.

273
00:14:58,431 --> 00:15:00,933
For example, sine has a fixpoint of zero.

274
00:15:01,168 --> 00:15:03,202
Cosine of zero is zero.

275
00:15:04,996 --> 00:15:07,473
Square root it turns out
it has two fixpoints.

276
00:15:07,473 --> 00:15:09,509
Square root of zero is
zero and the square root

277
00:15:09,509 --> 00:15:12,179
of one is one, so both zero and one will

278
00:15:12,179 --> 00:15:15,547
be fixpoints of the function square root.

279
00:15:15,781 --> 00:15:17,984
If you had an identity
function, any value you

280
00:15:17,984 --> 00:15:20,753
gave to an identity
function would be a fixpoint

281
00:15:20,753 --> 00:15:22,890
for the identity function, so there's an

282
00:15:22,890 --> 00:15:25,358
infinite number of
fixpoints for that function.

283
00:15:25,358 --> 00:15:26,894
And there's certainly some functions

284
00:15:26,894 --> 00:15:29,161
that have no fixpoints at all.

285
00:15:31,785 --> 00:15:33,569
Keep the idea of a fixpoint in your head,

286
00:15:33,569 --> 00:15:35,468
we're going to return to that.

287
00:15:37,244 --> 00:15:38,604
We're going to switch now to the

288
00:15:38,604 --> 00:15:41,775
live coding part of the demonstration.

289
00:15:45,488 --> 00:15:48,215
I'm going to, you guys are familiar with

290
00:15:48,215 --> 00:15:52,518
the stabby procs is Ruby 1.9, right?

291
00:15:52,885 --> 00:15:55,554
You call them by saying dot parentheses,

292
00:15:55,557 --> 00:15:57,256
that's at least one way to call them.

293
00:15:57,256 --> 00:15:59,659
I'm going to put this into
my codebase right here so

294
00:15:59,659 --> 00:16:01,761
I can just type in something
and the last thing in

295
00:16:01,761 --> 00:16:04,397
this list of expressions
when I evaluate the buffer

296
00:16:04,397 --> 00:16:08,801
will just return the last
thing in that expression.

297
00:16:09,135 --> 00:16:11,137
That's just going to
be a convenient way for

298
00:16:11,137 --> 00:16:14,140
me to evaluate a buffer
and print things out.

299
00:16:15,174 --> 00:16:19,245
Let's talk about the problem
with lambda calculus.

300
00:16:19,245 --> 00:16:22,181
I'm going to demonstrate it by
writing a factorial function.

301
00:16:23,641 --> 00:16:25,651
We'll use the stabby proc notation.

302
00:16:26,860 --> 00:16:29,256
Factorial is a function of
what argument, if that argument

303
00:16:29,256 --> 00:16:33,960
is zero then the result of
factorial of zero should be one.

304
00:16:35,220 --> 00:16:37,530
If it's not zero the
result of factorial should

305
00:16:37,530 --> 00:16:41,667
be n times the factorial of n minus one.

306
00:16:41,934 --> 00:16:44,986
I can prove that works by
calling factorial on five,

307
00:16:44,986 --> 00:16:48,942
and we know the factorial of five is 120.

308
00:16:49,957 --> 00:16:51,977
And indeed, that's what we get.

309
00:16:53,461 --> 00:16:55,582
But in lambda calculus I'm not really

310
00:16:55,582 --> 00:16:58,184
allowed to assign things like this.

311
00:16:58,184 --> 00:17:01,987
I have to create a lambda expression
and then call it directly.

312
00:17:01,987 --> 00:17:05,691
I'm going to try to call my
factorial problem like this,

313
00:17:05,925 --> 00:17:11,264
and it says, oh, I don't
have a method called fact

314
00:17:12,202 --> 00:17:15,340
defined anywhere, and that's
because I'm using fact

315
00:17:15,340 --> 00:17:19,672
in the definition of the
function I'm defining.

316
00:17:20,139 --> 00:17:23,742
Well in lambda calculus all
functions are anonymous,

317
00:17:24,900 --> 00:17:27,446
so how in the world can
I define that factorial

318
00:17:27,446 --> 00:17:30,916
without referring to
itself? That's a problem.

319
00:17:30,916 --> 00:17:35,287
How can lambda calculus
possibly be Turing complete?

320
00:17:35,888 --> 00:17:38,792
I'm going to leave that comment up there,

321
00:17:39,226 --> 00:17:41,127
and just think about that for a while.

322
00:17:41,127 --> 00:17:44,497
There's about four topics,
three or four topics I want

323
00:17:44,497 --> 00:17:48,167
to cover first before we go
back and solve this problem.

324
00:17:48,334 --> 00:17:49,544
The first thing we've already talked

325
00:17:49,544 --> 00:17:51,706
about, the first thing is fixpoints.

326
00:17:51,706 --> 00:17:54,173
You guys know what a fixpoint is,

327
00:17:54,240 --> 00:17:55,975
it's a value when given to a function,

328
00:17:55,975 --> 00:17:58,377
the function returns
that same value again.

329
00:17:58,445 --> 00:18:03,383
The next thing I want to talk
about it higher order functions.

330
00:18:05,751 --> 00:18:09,372
How many people here are familiar
with higher order functions?

331
00:18:10,022 --> 00:18:11,491
Yeah, I suspect most of us are.

332
00:18:11,491 --> 00:18:13,226
The rest of us who are
not, probably use them

333
00:18:13,226 --> 00:18:15,195
all the time and don't
really realize that.

334
00:18:15,195 --> 00:18:19,805
In Ruby, each, in its own sense,
is a higher order function.

335
00:18:20,845 --> 00:18:22,503
Let's talk about regular functions first.

336
00:18:22,503 --> 00:18:24,170
I'm going to write a
function called add one

337
00:18:24,170 --> 00:18:26,373
that takes a number and adds one to it.

338
00:18:26,373 --> 00:18:29,442
I can demonstrate that
add one works by giving

339
00:18:29,442 --> 00:18:32,512
it 10 and I should get an 11 out of that.

340
00:18:33,245 --> 00:18:36,015
Add one is a very simple function.

341
00:18:37,238 --> 00:18:40,085
Let's do another simple
function, just for demo purposes.

342
00:18:40,453 --> 00:18:42,122
It's going to be multiply by three,

343
00:18:42,122 --> 00:18:44,156
we'll take n and multiply it by three.

344
00:18:44,223 --> 00:18:48,194
We'll multiply by three
the result of adding

345
00:18:48,194 --> 00:18:51,497
one to ten and we should
get 33 out of that.

346
00:18:52,064 --> 00:18:55,067
Add one and mul three are
both basic simple functions,

347
00:18:55,067 --> 00:18:57,236
they take a value, they return a value.

348
00:18:57,471 --> 00:18:59,738
Let's write a higher order function now.

349
00:19:09,148 --> 00:19:12,818
Make adder is a function
that takes an argument x,

350
00:19:13,219 --> 00:19:17,831
and what it's going to return
is another function that

351
00:19:17,831 --> 00:19:22,795
takes an argument n, that
adds x and n together.

352
00:19:24,564 --> 00:19:28,300
Make adder is a function
that creates a new function.

353
00:19:28,534 --> 00:19:30,870
Given the x it will take that x and it

354
00:19:30,870 --> 00:19:32,805
will create a new function that will add x

355
00:19:32,805 --> 00:19:35,675
to anything that you give to the new x.

356
00:19:35,675 --> 00:19:39,078
So I could actually have
rewritten add one like this.

357
00:19:39,078 --> 00:19:42,681
Make adder one.

358
00:19:43,783 --> 00:19:47,286
And that's a decent definition of add one.

359
00:19:47,286 --> 00:19:48,854
We can evaluate our
buffer and see we get the

360
00:19:48,854 --> 00:19:52,491
33 back, so add one
obviously must be working.

361
00:19:53,327 --> 00:19:56,228
Make adder is a higher
order function, it's higher

362
00:19:56,228 --> 00:19:59,965
order because its return
value is a function itself.

363
00:20:00,165 --> 00:20:01,600
That's all it means to be a higher order

364
00:20:01,600 --> 00:20:04,836
function, it returns functional values.

365
00:20:05,138 --> 00:20:08,108
Here's another higher order
function, we'll call it compose.

366
00:20:08,708 --> 00:20:12,178
Compose takes functions as argument,

367
00:20:12,178 --> 00:20:15,080
two functions in this case, f and g.

368
00:20:15,248 --> 00:20:19,018
It's also going to return
a function that's going to

369
00:20:19,018 --> 00:20:26,125
compose f on top of g called
on n, and return a new

370
00:20:26,125 --> 00:20:29,261
function that calls f and
g on top of each other.

371
00:20:29,261 --> 00:20:32,364
We can now create a function
called mul three add one

372
00:20:32,364 --> 00:20:37,302
that is the composition
of mul three and add one.

373
00:20:38,837 --> 00:20:41,140
Then we can use that newly
composed method right

374
00:20:41,140 --> 00:20:45,944
here and we see we get
the same answer 33 back.

375
00:20:46,011 --> 00:20:48,614
Compose is a higher order function.

376
00:20:48,614 --> 00:20:50,351
It's higher order for two reasons.

377
00:20:50,351 --> 00:20:52,185
It returns a function, but it also takes

378
00:20:52,185 --> 00:20:54,087
functions as arguments,
and that's enough to

379
00:20:54,087 --> 00:20:56,522
make it a higher order function as well.

380
00:20:56,789 --> 00:21:01,462
We are going to use higher
order functions a lot in the

381
00:21:01,462 --> 00:21:04,063
rest of this demo, so if
you've never seen them before

382
00:21:04,063 --> 00:21:07,100
just get comfortable with
the fact that functions are

383
00:21:07,100 --> 00:21:09,168
values and we can manipulate
them just like we can

384
00:21:09,168 --> 00:21:12,037
manipulates strings and
integers and what not.

385
00:21:15,087 --> 00:21:21,480
Next topic will be
functional refactorings.

386
00:21:27,447 --> 00:21:30,356
Just like in the object-oriented world,

387
00:21:30,356 --> 00:21:32,324
there are refactorings that we can do,

388
00:21:32,324 --> 00:21:35,728
like extract method or collapse hierarchy.

389
00:21:35,728 --> 00:21:38,464
There are a number of
refactorings that you

390
00:21:38,464 --> 00:21:40,767
can do in the functional world as well,

391
00:21:40,767 --> 00:21:43,169
and they are purely functional in flavor.

392
00:21:43,303 --> 00:21:44,704
The first one I want to talk about

393
00:21:44,704 --> 00:21:48,073
is the Tennent correspondence principle.

394
00:21:55,148 --> 00:21:59,085
Tennent says if I have an
expression x and I surround it by

395
00:21:59,085 --> 00:22:04,423
a lambda, and then immediately
call that lambda, I get x back.

396
00:22:04,823 --> 00:22:06,326
It essentially has no effect.

397
00:22:06,326 --> 00:22:08,927
It's a true refactoring, in that
it does not affect the code.

398
00:22:09,095 --> 00:22:10,764
Let's demonstrate that.

399
00:22:10,863 --> 00:22:15,300
Let's go down here to mul
three and inside mul three ...

400
00:22:17,336 --> 00:22:19,571
Inside mul three I'm going to wrap this

401
00:22:19,571 --> 00:22:23,542
expression inside a lambda,
and then immediately

402
00:22:23,542 --> 00:22:25,978
call the lambda, that's
the Tennent principle.

403
00:22:26,045 --> 00:22:28,880
And we see that it has
no effect on the outcome,

404
00:22:28,949 --> 00:22:31,350
we still get 33, it is a true refactoring.

405
00:22:31,617 --> 00:22:33,385
Let's do it one more time.

406
00:22:33,586 --> 00:22:37,890
I'm going to wrap this whole functional

407
00:22:37,890 --> 00:22:41,261
expression in a Tennent lambda.

408
00:22:41,461 --> 00:22:43,730
And this time I'm going to
do it with an editor macro

409
00:22:43,730 --> 00:22:48,201
just to show that these
things truly are mechanical.

410
00:22:48,801 --> 00:22:54,106
There, my editor did it for me,
and yes, we get 33 out of it.

411
00:22:54,473 --> 00:22:58,144
The Tennent principle, very
useful in functional refactoring.

412
00:22:58,310 --> 00:23:03,015
Our next refactoring would
be to introduce a binding.

413
00:23:03,882 --> 00:23:07,587
If I have a lambda here with no arguments,

414
00:23:07,587 --> 00:23:10,389
I can add a new argument binding to it.

415
00:23:10,623 --> 00:23:13,459
We'll call it z.

416
00:23:14,393 --> 00:23:17,263
If I add an argument here,
when I call it I have to give

417
00:23:17,263 --> 00:23:20,933
it a value, and I can give it
any value that I feel like.

418
00:23:21,200 --> 00:23:24,737
Because z is not used anywhere
it doesn't matter what

419
00:23:24,737 --> 00:23:29,108
value it takes, so I can
introduce the argument z

420
00:23:29,108 --> 00:23:32,978
and evaluate that and
it's still 33, no effect.

421
00:23:33,279 --> 00:23:35,434
Now there's one rule you have to follow,

422
00:23:36,264 --> 00:23:38,685
and let's demonstrate that here.

423
00:23:42,901 --> 00:23:45,424
You have to make sure that anything,

424
00:23:45,424 --> 00:23:47,694
any variable you add
in, that you introduce,

425
00:23:47,694 --> 00:23:51,062
is not free in the
expression you're wrapping.

426
00:23:51,430 --> 00:23:54,466
Down in here we've got variable n.

427
00:23:54,466 --> 00:23:56,703
n is not free because
it's bound right here.

428
00:23:56,703 --> 00:23:59,194
I could actually reuse n. It
would be confusing but I could.

429
00:23:59,194 --> 00:24:02,708
But f and g are both free variables in

430
00:24:02,708 --> 00:24:05,110
this expression, they're defined outside.

431
00:24:06,078 --> 00:24:08,981
So if I were to take f in here and give

432
00:24:08,981 --> 00:24:11,917
it an arbitrary value, it would die.

433
00:24:12,818 --> 00:24:17,222
Whereas if I called it n, that would work.

434
00:24:18,682 --> 00:24:21,894
Generally I'm going to avoid
using any used variable at all,

435
00:24:21,894 --> 00:24:26,899
so xyzzy is a good choice
there, and that works.

436
00:24:26,899 --> 00:24:28,867
As long as you stay
away from free variables

437
00:24:28,867 --> 00:24:30,470
in the expression you're wrapping it

438
00:24:30,470 --> 00:24:32,806
doesn't matter what the variable name is.

439
00:24:34,166 --> 00:24:38,010
Number three will be wrap function.

440
00:24:38,377 --> 00:24:41,446
If I have an expression
that is a function of one

441
00:24:41,446 --> 00:24:45,017
argument, I can wrap
that in a lambda of one

442
00:24:45,017 --> 00:24:47,786
argument and then call
the function inside that

443
00:24:47,786 --> 00:24:52,325
lambda and pass the argument
down to the call site.

444
00:24:52,791 --> 00:24:56,528
Let's demonstrate. Here is
a function of one argument.

445
00:24:56,995 --> 00:25:01,066
I can wrap it in a brand new
lambda with an argument of v.

446
00:25:03,558 --> 00:25:05,538
Then on the inner function
that I just wrapped

447
00:25:05,538 --> 00:25:08,608
I need to call it
immediately and pass v in.

448
00:25:09,075 --> 00:25:12,244
This essentially, what I'm
doing is make adder now returns

449
00:25:12,244 --> 00:25:16,616
a lambda that has the same
signature as the function

450
00:25:16,616 --> 00:25:18,884
it was previously returning,
but it doesn't actually

451
00:25:18,884 --> 00:25:23,456
evaluate the lambda on the
inside until you call it again.

452
00:25:23,456 --> 00:25:25,390
It's kind of like a delaying tactic.

453
00:25:25,390 --> 00:25:27,560
If you don't want to evaluate
something right away,

454
00:25:27,560 --> 00:25:29,595
this is something you can do to do that.

455
00:25:29,595 --> 00:25:31,763
And you can tell, I still
get 33 out of the result,

456
00:25:31,763 --> 00:25:35,800
so function wrapping
is a true refactoring.

457
00:25:36,535 --> 00:25:38,938
One final one, you're
going to love this one.

458
00:25:40,206 --> 00:25:42,908
This is inline definition.

459
00:25:42,908 --> 00:25:46,445
I can take any definition here,
in this case the definition

460
00:25:46,445 --> 00:25:50,783
of make adder, and wherever
make adder is called by name

461
00:25:50,783 --> 00:25:56,421
I can replace the name of make
adder with the definition.

462
00:25:57,923 --> 00:26:00,393
Let's delete this line here.

463
00:26:00,559 --> 00:26:04,196
And when I evaluate that, same result.

464
00:26:05,264 --> 00:26:06,932
Again this is totally mechanical.

465
00:26:06,932 --> 00:26:11,703
I can take compose and run the
inline refactoring on that.

466
00:26:14,145 --> 00:26:16,942
I get the same result back.

467
00:26:17,481 --> 00:26:19,711
Let's go wild with this one.

468
00:26:21,803 --> 00:26:24,216
Inline add one, no that's part of

469
00:26:24,216 --> 00:26:26,385
the name, but here's add one, yes.

470
00:26:26,585 --> 00:26:31,289
Let's inline mul three, there.

471
00:26:33,242 --> 00:26:35,523
(laughter)

472
00:26:35,523 --> 00:26:37,362
One more time guys.

473
00:26:39,098 --> 00:26:41,363
Let's inline this guy.

474
00:26:47,107 --> 00:26:50,176
I did promise you the worst
ruby code you'd ever see, right?

475
00:26:50,176 --> 00:26:52,411
(laughter)

476
00:26:52,444 --> 00:26:57,349
That mess, let's evaluate
it, still returns 33.

477
00:26:57,449 --> 00:27:01,687
(applause)

478
00:27:02,955 --> 00:27:05,357
The really interesting thing about this,

479
00:27:05,357 --> 00:27:07,759
this is a pure lambda expression.

480
00:27:07,994 --> 00:27:10,129
There are no assignments anywhere in this.

481
00:27:10,129 --> 00:27:12,964
The only binding that
we do to variable names

482
00:27:12,964 --> 00:27:15,901
is through calling these lambda functions,

483
00:27:17,300 --> 00:27:19,106
we do a lot of calling
of the lambda functions.

484
00:27:19,106 --> 00:27:21,173
That's really ugly and very unreadable,

485
00:27:21,173 --> 00:27:23,009
and I don't recommend
writing code like this,

486
00:27:23,009 --> 00:27:24,843
but it proves a very important principle,

487
00:27:24,843 --> 00:27:28,580
that lambda calculus, this
is the goal of what we

488
00:27:28,580 --> 00:27:31,050
want to get to in lambda
calculus is have one big

489
00:27:31,050 --> 00:27:34,153
lambda expression that
does this calculation.

490
00:27:34,888 --> 00:27:37,856
Okay, enough of the preliminaries.

491
00:27:40,796 --> 00:27:43,799
Seems a shame to write all that
and just delete it, doesn't it.

492
00:27:44,211 --> 00:27:46,965
Let's get back to the
problem of recursion.

493
00:27:48,067 --> 00:27:51,403
Let me grab my factorial thing and

494
00:27:51,403 --> 00:27:53,662
let's paste it back here, and uncomment.

495
00:27:53,662 --> 00:27:55,440
So this is what we're dealing with.

496
00:27:55,440 --> 00:27:58,643
I want to write a factorial
function that's recursive,

497
00:27:58,643 --> 00:28:02,981
and I can't because I
cannot refer to factorial

498
00:28:02,981 --> 00:28:04,716
inside the definition of factorial,

499
00:28:04,716 --> 00:28:07,386
because there are no
names for these functions.

500
00:28:07,687 --> 00:28:11,123
Well I could actually, there
are names that are introduced

501
00:28:11,123 --> 00:28:13,260
by lambda binding, so I
actually could do this.

502
00:28:14,136 --> 00:28:16,962
Let's create a function that
has factorial as an argument.

503
00:28:18,964 --> 00:28:22,901
And then, now factorial
will be bound to this.

504
00:28:25,663 --> 00:28:28,840
Let's call this make factorial.

505
00:28:29,274 --> 00:28:32,040
Then all I have to do
to create the factorial

506
00:28:32,040 --> 00:28:36,281
function is to call make
factorial, and all I need

507
00:28:36,281 --> 00:28:38,783
to do is pass in the
definition of factorial.

508
00:28:40,820 --> 00:28:42,888
Think about that for just a sec.

509
00:28:44,389 --> 00:28:46,225
Okay, I haven't solved the problem yet,

510
00:28:46,225 --> 00:28:49,828
I've just introduced
some indirection there.

511
00:28:52,152 --> 00:28:53,855
That's not going to work because to make

512
00:28:53,855 --> 00:28:56,001
a factorial I need the
definition of factorial.

513
00:28:56,001 --> 00:28:59,104
Little bit circular logic there,
I need to do something else.

514
00:28:59,104 --> 00:29:03,242
Maybe I can relax the
requirements a little bit.

515
00:29:03,242 --> 00:29:05,577
Maybe I don't need a
make factorial, maybe I

516
00:29:05,577 --> 00:29:09,180
need a function that is
a factorial improver.

517
00:29:09,448 --> 00:29:12,484
Instead of taking the definition
of factorial as an argument,

518
00:29:12,484 --> 00:29:17,656
it will take a partial definition
of factorial as an argument.

519
00:29:17,656 --> 00:29:20,760
And by partial I mean a
function that acts like

520
00:29:20,760 --> 00:29:24,630
factorial over a subset
of the possible inputs.

521
00:29:24,897 --> 00:29:28,567
In other words, if I have a
factorial function that works

522
00:29:28,567 --> 00:29:32,004
from zero to 10, it calculates
the factorial of zero,

523
00:29:32,004 --> 00:29:35,040
one, two, three, on up
to the factorial of 10.

524
00:29:35,040 --> 00:29:38,343
If I pass that partial
definition of factorial into

525
00:29:38,343 --> 00:29:43,082
my fact improver, I will get
out of that a new function

526
00:29:43,082 --> 00:29:46,652
that works for factorial from zero to 11,

527
00:29:46,818 --> 00:29:50,856
it improves any factorial
definition by one step.

528
00:29:51,323 --> 00:29:53,359
That's kind of cool.

529
00:29:56,253 --> 00:29:58,997
I need an error function here,

530
00:29:58,997 --> 00:30:01,100
so bare with my while I write this.

531
00:30:06,532 --> 00:30:08,207
This is just a function
of one argument that

532
00:30:08,207 --> 00:30:10,809
throws an error so we
can see what's happening.

533
00:30:13,211 --> 00:30:18,450
Now if I factorial improve,
factorial improver,

534
00:30:18,617 --> 00:30:22,822
and I call that on error,
I claim that I will

535
00:30:22,822 --> 00:30:26,525
get out of this a
function I'll call f zero,

536
00:30:26,525 --> 00:30:30,262
because f0 correctly calculates
the factorial of zero. Oops.

537
00:30:38,368 --> 00:30:41,072
I left this five on there, that
five should not be in there.

538
00:30:42,525 --> 00:30:46,711
Yes, it correctly calculates
the factorial of zero.

539
00:30:48,661 --> 00:30:51,983
That's interesting.

540
00:30:52,584 --> 00:30:54,687
Oh, but if I can calculate
the factorial of zero,

541
00:30:54,687 --> 00:30:57,422
I can create a function that
calculates the factorial of one.

542
00:31:03,395 --> 00:31:07,999
Yeah, but f one does not
calculate the factorial of two.

543
00:31:09,069 --> 00:31:11,537
But if I got one that
calculates one, I can

544
00:31:11,537 --> 00:31:19,012
write an f two based on
f one that works for two.

545
00:31:20,512 --> 00:31:23,748
Does it work for three? No, not at all.

546
00:31:24,116 --> 00:31:26,784
You can kind of see where
I'm going with this maybe.

547
00:31:27,486 --> 00:31:30,322
Before I go any further let's
inline some of these things.

548
00:31:30,322 --> 00:31:35,594
I'm going to do the inline
refactoring there and there.

549
00:31:37,027 --> 00:31:40,933
Let's call this fx right now,
not tied to a particular number.

550
00:31:41,100 --> 00:31:47,472
And then I'm going to take
this from here to here.

551
00:31:47,911 --> 00:31:49,775
I'm going to cut it and paste it

552
00:31:49,775 --> 00:31:52,544
one, two, three, four, five times.

553
00:31:53,398 --> 00:31:57,248
One, two, three, four, five
to balance the parentheses.

554
00:31:57,449 --> 00:32:00,853
And now fx calculates
the factorial of five.

555
00:32:02,305 --> 00:32:08,493
It will do 10, it will do
14, but it will not do 15.

556
00:32:10,451 --> 00:32:12,630
Well, I'm getting closer to my goal.

557
00:32:12,630 --> 00:32:15,655
(laughter)

558
00:32:16,702 --> 00:32:19,204
All I have to do is decide the biggest

559
00:32:19,204 --> 00:32:21,707
number I will ever want the factorial of

560
00:32:21,707 --> 00:32:24,175
(laughter)

561
00:32:25,297 --> 00:32:28,347
and call fact improver
on it that many times.

562
00:32:28,513 --> 00:32:30,281
Okay, maybe that's not
quite so practical, that's

563
00:32:30,281 --> 00:32:32,850
not going to get us the
real factorial function.

564
00:32:34,433 --> 00:32:36,722
Let's get rid of that.
Let's think about this.

565
00:32:36,722 --> 00:32:38,757
Before I go any farther let's go ahead and

566
00:32:38,757 --> 00:32:41,526
do the whole embed this in a lambda trick.

567
00:32:41,526 --> 00:32:44,310
I'm going to create a lambda function that

568
00:32:44,310 --> 00:32:48,766
expects a factorial
improver as an argument,

569
00:32:49,134 --> 00:32:51,403
and here's the body of that function.

570
00:32:53,705 --> 00:32:58,810
Should be open parentheses
and close parentheses.

571
00:32:58,831 --> 00:33:01,580
Here is the body of the function.

572
00:33:02,381 --> 00:33:04,349
Here is where I'm passing in the argument,

573
00:33:04,349 --> 00:33:06,784
I'm passing in the factorial improver.

574
00:33:06,886 --> 00:33:09,520
Let's just call it improver for right now.

575
00:33:09,956 --> 00:33:14,125
Then in here I can do the same
tricks I was doing elsewhere.

576
00:33:14,125 --> 00:33:21,466
I can say improver dot error,
and if I put this into fx

577
00:33:21,466 --> 00:33:26,537
and fx should work for one,
but it won't work for two.

578
00:33:29,164 --> 00:33:31,576
This is exactly the
same thing I did before,

579
00:33:31,576 --> 00:33:34,212
except I've embedded it in a lambda.

580
00:33:35,796 --> 00:33:38,384
Instead of assigning to
improver I'm binding to it with

581
00:33:38,384 --> 00:33:42,754
lambda binding, which is what
we want to get to anyways.

582
00:33:43,621 --> 00:33:46,358
Improver is interesting.
Improver says I can

583
00:33:46,358 --> 00:33:49,227
take any function and
improve it by one step.

584
00:33:49,261 --> 00:33:52,163
I was using this error
thing, which obviously

585
00:33:52,163 --> 00:33:54,766
has nothing to do with factorial at all.

586
00:33:54,766 --> 00:34:00,805
But I'm wondering if I replaced
error with just improver,

587
00:34:02,443 --> 00:34:07,578
I should get a function that
works for factorial of zero.

588
00:34:10,377 --> 00:34:12,283
And it does.

589
00:34:12,717 --> 00:34:15,105
But if I call factorial
of one it should fail

590
00:34:15,105 --> 00:34:16,956
in a weird way, and the
weird way is that it

591
00:34:16,956 --> 00:34:20,125
says that proc can't
be coerced to a fixnum.

592
00:34:20,125 --> 00:34:24,369
The error happens right here on this line,

593
00:34:24,369 --> 00:34:27,932
right at this multiply, where
it's taking n times that.

594
00:34:27,932 --> 00:34:33,305
This partial now is the
improver function and improvers

595
00:34:33,305 --> 00:34:37,509
expect functions, not numbers,
so of course it's not working.

596
00:34:37,509 --> 00:34:40,179
In fact we can make this much plainer if

597
00:34:40,179 --> 00:34:44,917
I replace the word partial
with improver here.

598
00:34:48,891 --> 00:34:53,491
Since I'm passing in improver to improver,

599
00:34:53,558 --> 00:34:56,910
and this is improver, so
let's call it improver

600
00:34:56,910 --> 00:34:59,264
as the argument, I'm actually doing that.

601
00:34:59,264 --> 00:35:01,300
And this becomes very plain
that improver does not

602
00:35:01,300 --> 00:35:05,036
take a numeric argument,
improver expects a function.

603
00:35:07,894 --> 00:35:10,275
Well, I've got a function laying around.

604
00:35:10,542 --> 00:35:13,746
Let's pass an improver. (laughter)

605
00:35:16,581 --> 00:35:19,083
Gosh, I wonder if this
could possibly work.

606
00:35:20,469 --> 00:35:22,553
Well factorial of one is good.

607
00:35:23,355 --> 00:35:27,758
How about factorial of
two? Oh, how about five.

608
00:35:29,282 --> 00:35:31,063
How about 50?

609
00:35:31,359 --> 00:35:33,046
How about 500?

610
00:35:35,807 --> 00:35:38,638
I think I can go up to 2000
before I overflow my stack.

611
00:35:40,068 --> 00:35:42,273
So there, factorial of 2000.

612
00:35:47,234 --> 00:35:51,150
Here you go. Let's make
this all the way pure lambda

613
00:35:51,150 --> 00:35:54,019
calculus by defining the
function and then calling it

614
00:35:54,019 --> 00:35:56,521
with the argument five at
the end here, and we will

615
00:35:56,521 --> 00:36:00,525
have a pure lambda expression
that calculates factorial.

616
00:36:04,096 --> 00:36:07,632
(applause)

617
00:36:12,038 --> 00:36:15,373
Now this is good enough for our goal of

618
00:36:15,373 --> 00:36:17,909
proving that lambda calculus can actually

619
00:36:17,909 --> 00:36:21,479
calculate arbitrary
mathematical functions.

620
00:36:21,780 --> 00:36:24,583
Recursion is no problem
for it by doing this little

621
00:36:24,583 --> 00:36:29,988
trick of passing these
things to itself, it actually

622
00:36:32,480 --> 00:36:35,466
can do recursion with
lambda calculus, even though

623
00:36:35,974 --> 00:36:38,396
lambda calculus is nothing
but anonymous functions.

624
00:36:38,564 --> 00:36:40,798
This is mind blowing to me actually.

625
00:36:40,900 --> 00:36:45,836
But I'm still not quite happy
with this definition here.

626
00:36:48,342 --> 00:36:49,974
There's two things I don't like about it.

627
00:36:49,974 --> 00:36:53,011
First of all, I'm calling
this thing improver and it's

628
00:36:53,011 --> 00:36:57,249
no longer improver, improver
took a partial definition.

629
00:36:57,282 --> 00:37:01,687
This function is taking
something that is not a partial

630
00:37:01,687 --> 00:37:04,589
definition, so this thing
here should not be called

631
00:37:04,589 --> 00:37:07,325
improver at all, it should
be called something else.

632
00:37:07,325 --> 00:37:10,563
So let's replace the name
improver with a different name,

633
00:37:10,563 --> 00:37:13,398
and here I get stuck,
because I have no common

634
00:37:13,398 --> 00:37:18,670
name for the thing that
this argument now is.

635
00:37:18,703 --> 00:37:20,538
It's no longer an improver function.

636
00:37:20,538 --> 00:37:23,509
I'm going to go with the name gen,

637
00:37:23,808 --> 00:37:27,812
because it's a generator that
somehow when you feed it itself,

638
00:37:27,812 --> 00:37:32,817
when it swallows itself, it
generates a recursive function.

639
00:37:33,518 --> 00:37:35,424
If we can live with that,
that's what I'm going

640
00:37:35,424 --> 00:37:38,156
to call it for the purposes
of this demonstration.

641
00:37:38,757 --> 00:37:40,326
I can see that I haven't changed anything,

642
00:37:40,326 --> 00:37:42,993
we still have a working
factorial system there.

643
00:37:43,328 --> 00:37:45,031
That's the number one thing I didn't like.

644
00:37:45,031 --> 00:37:47,799
The second thing is that
if I were to sit down and

645
00:37:47,799 --> 00:37:52,171
write a recursive function
it would never in my

646
00:37:52,171 --> 00:37:55,506
entire life occur to me to
write it in this manner.

647
00:37:55,808 --> 00:38:00,778
There's lots of mechanics right here

648
00:38:00,778 --> 00:38:03,649
involved in just to do the recursion.

649
00:38:05,356 --> 00:38:07,085
If I could get this in a form where I was

650
00:38:07,085 --> 00:38:09,955
writing factorial as an improver function,

651
00:38:09,955 --> 00:38:12,156
improver function makes
a lot of sense to me,

652
00:38:12,156 --> 00:38:14,159
that seems more or less natural,

653
00:38:14,159 --> 00:38:15,927
at least in the lambda calculus world.

654
00:38:15,927 --> 00:38:18,498
If I could get back to
the improver form of this

655
00:38:18,498 --> 00:38:21,232
I would be really glad,
so let's see if we can

656
00:38:21,232 --> 00:38:24,402
work on this code base a little bit.

657
00:38:24,836 --> 00:38:27,873
I'm going to take this inner
lambda right here and I'm going

658
00:38:27,873 --> 00:38:32,243
to do the Tennent correspondence
principle refactoring on it.

659
00:38:35,550 --> 00:38:37,882
Let's break that up
just a little bit here.

660
00:38:38,250 --> 00:38:42,454
I wrapped this in a lambda
and immediately called the

661
00:38:42,454 --> 00:38:45,923
lambda and it has no effect,
it does the same thing.

662
00:38:46,000 --> 00:38:48,493
We still have a working factorial,
it didn't break anything.

663
00:38:48,493 --> 00:38:51,117
Now I'm going to introduce a binding,

664
00:38:53,640 --> 00:38:56,918
and the variable name
I'm going to use is code,

665
00:38:56,918 --> 00:38:58,425
that's the name of the variable,

666
00:38:58,425 --> 00:39:01,439
and the value I'm going to pass
in will be my error function.

667
00:39:01,986 --> 00:39:05,611
Remember when you introduce a
variable, introduce a binding,

668
00:39:05,611 --> 00:39:08,247
the value doesn't matter,
it can be anything.

669
00:39:08,755 --> 00:39:12,784
There I have a function that
takes an argument of code,

670
00:39:12,951 --> 00:39:14,852
and I'm passing in the error function.

671
00:39:14,852 --> 00:39:18,022
We're not using code anywhere
so we never trigger the error,

672
00:39:18,023 --> 00:39:20,791
and it still results 120
for the factorial five.

673
00:39:23,476 --> 00:39:26,230
Well I can pass anything
in, let's pass in gen.

674
00:39:27,274 --> 00:39:29,134
Hey, that still works too.

675
00:39:30,163 --> 00:39:35,507
This whole gen of gen thing is a
function, let's call gen of gen.

676
00:39:37,742 --> 00:39:42,081
Oops. Stack too deep.

677
00:39:42,280 --> 00:39:44,082
This is what has happened.

678
00:39:44,082 --> 00:39:50,221
I'm calling gen of gen inside
of here, so this entire thing,

679
00:39:52,159 --> 00:39:54,892
this entire thing right
here is the gen function,

680
00:39:54,892 --> 00:39:59,193
so when I call gen and pass in gen,

681
00:40:00,116 --> 00:40:03,535
it goes and it would call
gen of gen inside of it,

682
00:40:03,535 --> 00:40:08,472
but it only called it if n was not zero,

683
00:40:09,040 --> 00:40:12,344
so it actually bottomed out,
it would actually terminate.

684
00:40:12,410 --> 00:40:15,530
Here I'm passing in gen
or gen and it always calls

685
00:40:15,530 --> 00:40:19,250
gen of gen, even when n is
zero, so it has infinite

686
00:40:19,250 --> 00:40:22,587
recursive depth in there,
and that's no good.

687
00:40:22,954 --> 00:40:26,757
If there were only some
way of delaying evaluation.

688
00:40:28,292 --> 00:40:30,028
Let's wrap it in a function.

689
00:40:32,078 --> 00:40:36,100
There's my wrap function.
Argument name will be v.

690
00:40:36,501 --> 00:40:40,973
There I've taken gen of gen
and replaced it with a lambda

691
00:40:40,973 --> 00:40:43,910
so when I call it it
doesn't infinitely recurse,

692
00:40:43,910 --> 00:40:46,711
it just passes the
lambda in in it's place,

693
00:40:46,711 --> 00:40:50,048
that's functionally equivalent
to calling gen of gen.

694
00:40:50,182 --> 00:40:52,583
And we see, this actually works.

695
00:40:54,620 --> 00:40:56,755
Okay, next step.

696
00:40:57,088 --> 00:40:59,590
I've got code, code is
bound to that lambda that

697
00:40:59,590 --> 00:41:04,363
evaluates to gen of gen,
and we know that here,

698
00:41:04,363 --> 00:41:07,698
let's go ahead and wrap this as well.

699
00:41:09,567 --> 00:41:13,272
I see right here, from
here to here, this is

700
00:41:13,272 --> 00:41:15,503
the exact same thing that I'm passing in

701
00:41:16,318 --> 00:41:20,211
to code so let's just call code instead.

702
00:41:22,624 --> 00:41:24,548
And that works.

703
00:41:27,531 --> 00:41:29,187
That's interesting.

704
00:41:29,187 --> 00:41:31,890
Let's rename code to partial.

705
00:41:33,224 --> 00:41:35,193
All of a sudden, out of nowhere,

706
00:41:35,193 --> 00:41:36,961
that little piece of
code right there is our

707
00:41:36,961 --> 00:41:41,599
improver function,
we've got it back. Cool.

708
00:41:42,645 --> 00:41:44,535
But it's still buried in
the middle of all this

709
00:41:44,535 --> 00:41:46,837
recursive stuff, let's
see if we can pull it out.

710
00:41:47,171 --> 00:41:51,080
Out here, from here down to
here, not including the argument

711
00:41:51,080 --> 00:41:53,878
call but the entire body of
the function, I'm going to do

712
00:41:53,878 --> 00:41:57,548
a Tennent refactoring again,
that wraps it in a lambda.

713
00:41:58,417 --> 00:42:01,720
Let's put some line feeds in and pretty

714
00:42:01,720 --> 00:42:03,954
up the indentation a little bit there.

715
00:42:07,399 --> 00:42:09,961
I'm going to introduce a
new binding here again.

716
00:42:12,775 --> 00:42:16,568
The binding will be code, the
value will be error again,

717
00:42:16,568 --> 00:42:18,569
because that worked so
well for us last time.

718
00:42:19,604 --> 00:42:21,972
And that still works, that's still 120.

719
00:42:23,377 --> 00:42:26,978
Now I'm going to point out
that here is the improver.

720
00:42:27,413 --> 00:42:31,415
I'm going to copy the
improver from here and call,

721
00:42:37,350 --> 00:42:42,927
pass in the improver as the value of code.

722
00:42:44,562 --> 00:42:47,264
And that still works because
we're not using code.

723
00:42:47,365 --> 00:42:50,002
But I point out that code
is now the same thing

724
00:42:50,002 --> 00:42:52,070
as the improver function embedded in here.

725
00:42:52,070 --> 00:42:56,441
I can replace this now with
code and it still is 120.

726
00:42:58,175 --> 00:43:02,647
Now let's rename code to be improver.

727
00:43:11,507 --> 00:43:14,642
I was practicing this this
morning and I was typing improver

728
00:43:14,642 --> 00:43:18,897
so often all of a sudden I
started reading it as imp rover.

729
00:43:23,071 --> 00:43:25,403
Replace those two with improver

730
00:43:25,403 --> 00:43:27,705
and we still got 120 out of that.

731
00:43:28,673 --> 00:43:32,309
And there we have, we have a
complete lambda expression.

732
00:43:32,476 --> 00:43:35,646
Here, this part of the
code right here deals

733
00:43:35,646 --> 00:43:39,083
with the recursive nature of the problem.

734
00:43:39,917 --> 00:43:42,086
This piece right here
is the only piece that

735
00:43:42,086 --> 00:43:45,122
knows anything about the
definition of factorial.

736
00:43:45,856 --> 00:43:48,093
So this is really nice,
this is exactly what I want,

737
00:43:48,093 --> 00:43:50,828
and now that I've got a
complete lambda expression

738
00:43:50,828 --> 00:43:52,865
that does this I'm going
to pull the pieces out and

739
00:43:52,865 --> 00:43:55,900
name them so we can talk
about them reasonably.

740
00:43:56,500 --> 00:43:58,302
Let's pull this out, I'm going to call

741
00:43:58,302 --> 00:44:03,641
this fact improver again, imp rover.

742
00:44:05,777 --> 00:44:09,547
And let's put it up here.
Fact improver is that.

743
00:44:14,971 --> 00:44:18,989
Nice indentation. Still works, no problem.

744
00:44:19,191 --> 00:44:21,859
Let's take out this piece right here.

745
00:44:24,012 --> 00:44:26,263
I'm going to call this piece y.

746
00:44:30,401 --> 00:44:33,170
Get some nice indentation going on that.

747
00:44:34,839 --> 00:44:38,442
Then I'm going to take this out here and

748
00:44:38,442 --> 00:44:42,080
I'm going to call this
piece fact, or factorial.

749
00:44:42,980 --> 00:44:46,884
Then we'll call factorial right
there, everything still works.

750
00:44:47,184 --> 00:44:49,053
I'm going to clean this code base up just

751
00:44:49,053 --> 00:44:53,190
a little bit here,
streamline it just a wee bit.

752
00:44:55,883 --> 00:44:57,762
Now I've got three pieces.

753
00:44:57,762 --> 00:44:59,897
Let's start with the
bottom and work our way up.

754
00:45:03,365 --> 00:45:05,805
This is factorial, this is
the real factorial function

755
00:45:05,805 --> 00:45:09,608
and I prove it by calling
factorial five and

756
00:45:09,608 --> 00:45:12,311
it actually does calculate
the factorial of five.

757
00:45:12,543 --> 00:45:14,846
If I were to take the factorial function

758
00:45:14,846 --> 00:45:19,017
and run it through the fact improver

759
00:45:22,293 --> 00:45:23,921
what will come out of that?

760
00:45:27,291 --> 00:45:28,926
Well fact improver takes a partial

761
00:45:28,926 --> 00:45:31,095
function and improves it by one step.

762
00:45:31,096 --> 00:45:33,597
But if I've already got the
real factorial function,

763
00:45:33,597 --> 00:45:37,501
all improver can do is return
the factorial function.

764
00:45:39,403 --> 00:45:44,008
This is indeed the factorial function.

765
00:45:44,008 --> 00:45:46,877
I can run this and I still get 120.

766
00:45:46,977 --> 00:45:50,948
We're using this definition of
factorial now, not this one,

767
00:45:50,948 --> 00:45:55,586
and that proves that fact
improver returns its argument.

768
00:45:59,267 --> 00:46:06,664
Factorial is the fixpoint
of fact improver.

769
00:46:09,308 --> 00:46:12,069
I'm going to say imp rover now
in my head every time I do that.

770
00:46:12,603 --> 00:46:17,141
Factorial is the fixpoint
of fact improver.

771
00:46:17,357 --> 00:46:20,711
Higher order functions
have fixpoints as well.

772
00:46:20,711 --> 00:46:22,948
Their fixpoints happen
to be functions, but that

773
00:46:22,948 --> 00:46:25,816
doesn't change the fact
that they're fixpoints.

774
00:46:27,724 --> 00:46:31,989
Now I'd like to point
out that the function y

775
00:46:31,989 --> 00:46:42,166
calculates the fixpoint
of an improver function.

776
00:46:43,101 --> 00:46:45,269
In this case we're calculating
the fixpoint of the fact

777
00:46:45,269 --> 00:46:48,439
improver, but I could write
any recursive function I wanted

778
00:46:48,439 --> 00:46:51,993
to and it would calculate the
fixpoint of that recursive

779
00:46:51,993 --> 00:46:56,547
function, as long as it's
done in an improver style.

780
00:46:56,582 --> 00:46:59,250
I could write a Fibonacci improver

781
00:46:59,250 --> 00:47:02,286
and it would work perfectly well.

782
00:47:02,386 --> 00:47:05,601
y calculates that, so let's talk about y.

783
00:47:05,601 --> 00:47:09,193
y here is actually the y combinator

784
00:47:09,293 --> 00:47:11,295
that we've all heard about and loved.

785
00:47:11,637 --> 00:47:13,364
Well, maybe not loved.

786
00:47:14,748 --> 00:47:17,101
In particular this, there's actually many,

787
00:47:17,101 --> 00:47:19,670
many, many versions of the
y combinator, and if you

788
00:47:19,670 --> 00:47:22,773
go to Wikipedia you will
not see this version at all.

789
00:47:24,893 --> 00:47:29,381
First of all, mathematicians don't
like intention-revealing names.

790
00:47:30,047 --> 00:47:32,550
(laughter)

791
00:47:32,550 --> 00:47:40,157
So they call improver f, and
they call the generator function,

792
00:47:40,157 --> 00:47:43,694
I've seen it called g,
I've also seen it called x.

793
00:47:43,861 --> 00:47:47,766
The Wikipedia article uses
x so we'll use that here.

794
00:47:48,808 --> 00:47:52,369
So this is probably more likely
the form of the y combinator

795
00:47:52,369 --> 00:47:55,873
you'll see with variable names
f and x in it, but we haven't

796
00:47:55,873 --> 00:47:59,177
changed anything, we're
still calculating factorial.

797
00:47:59,810 --> 00:48:02,513
The other issue here is this in particular

798
00:48:02,513 --> 00:48:10,388
is the applicative order y combinator.

799
00:48:11,018 --> 00:48:12,924
Ruby is an applicative language.

800
00:48:12,924 --> 00:48:15,226
In other words it evaluates
its arguments before

801
00:48:15,226 --> 00:48:17,628
it passes the arguments
down into functions.

802
00:48:17,628 --> 00:48:20,297
Ruby is applicative,
Python is applicative,

803
00:48:22,496 --> 00:48:25,569
Lisp and Clojure are all
applicative languages.

804
00:48:25,569 --> 00:48:29,473
Examples of language that are
not applicative would be Pascal.

805
00:48:29,573 --> 00:48:31,609
Pascal is lazy, it will
evaluate its arguments

806
00:48:31,609 --> 00:48:34,044
only at the point it really needs them.

807
00:48:34,295 --> 00:48:37,648
There's a version of the y
combinator for normal order

808
00:48:37,648 --> 00:48:41,452
languages like Pascal, and the
difference is that you don't

809
00:48:41,452 --> 00:48:45,623
have to introduce this wrap
function thing right here

810
00:48:45,790 --> 00:48:48,625
that we had to do to prevent
our infinite stack recursion.

811
00:48:48,893 --> 00:48:52,529
That would be the normal
order y combinator.

812
00:48:53,030 --> 00:48:55,533
When you talk about y
combinators normally they

813
00:48:55,533 --> 00:48:58,402
mean the normal order in
the mathematical sense.

814
00:48:58,837 --> 00:49:00,705
In a language like Ruby we need to use

815
00:49:00,705 --> 00:49:02,640
the applicative order version instead.

816
00:49:02,640 --> 00:49:04,150
The applicative order has another name,

817
00:49:04,150 --> 00:49:05,976
it's called the z combinator.

818
00:49:07,046 --> 00:49:10,014
Why these things have so
many names I have no idea.

819
00:49:10,014 --> 00:49:13,585
It's also known as the
fixpoint combinator,

820
00:49:13,984 --> 00:49:16,320
because it is the combinator that

821
00:49:16,320 --> 00:49:19,156
calculates fixpoints of functions.

822
00:49:19,590 --> 00:49:21,192
There you have it.

823
00:49:21,492 --> 00:49:23,293
Oh, oh, one more thing.

824
00:49:23,293 --> 00:49:25,362
If you go to the Wikipedia page you

825
00:49:25,362 --> 00:49:28,598
will not find it in exactly this format,

826
00:49:28,600 --> 00:49:31,569
there's a preferred style
they like to write it.

827
00:49:31,802 --> 00:49:34,839
I'll show you that through
two refactorings here.

828
00:49:34,839 --> 00:49:37,541
Remember f is really the name
of the improver function,

829
00:49:37,541 --> 00:49:41,078
so if I call f on this x of x thing,

830
00:49:41,078 --> 00:49:43,981
I'm just improving the factorial function,

831
00:49:44,014 --> 00:49:46,051
and that is a no-op in this term.

832
00:49:46,051 --> 00:49:48,653
This still returns 120, no change.

833
00:49:48,953 --> 00:49:52,290
Then I can also do a function wrap here.

834
00:49:57,027 --> 00:49:59,129
We know function wrap
doesn't change anything,

835
00:49:59,129 --> 00:50:00,866
and you can see it doesn't.

836
00:50:00,866 --> 00:50:03,567
Then if I take off two
levels of indentation,

837
00:50:03,567 --> 00:50:06,238
all of a sudden you see a
great symmetry between the

838
00:50:06,238 --> 00:50:09,773
body of the function and the
argument you're passing in.

839
00:50:09,773 --> 00:50:12,176
This is the version you will
probably see if you look it

840
00:50:12,176 --> 00:50:16,480
up in Wikipedia or some math
on computational science.

841
00:50:16,547 --> 00:50:18,723
There you have it, there
is the y combinator

842
00:50:18,723 --> 00:50:21,915
derived from [first] principles.

843
00:50:24,789 --> 00:50:29,527
(applause)

844
00:50:33,430 --> 00:50:36,033
Wow, my brain is dead after that one.

845
00:50:37,168 --> 00:50:38,969
I started on this journey because I always

846
00:50:38,969 --> 00:50:41,005
heard about the y
combinator, and I really,

847
00:50:41,005 --> 00:50:42,940
really, really wanted to understand it.

848
00:50:42,940 --> 00:50:44,642
Now people ask, "Oh, that's cool!

849
00:50:44,642 --> 00:50:48,012
"How can I use the y
combinator in my own code?"

850
00:50:49,642 --> 00:50:52,984
Well if you have named functions,

851
00:50:52,984 --> 00:50:55,219
you don't need the y combinator.

852
00:50:55,219 --> 00:50:57,621
If you want to write all your
code as anonymous functions,

853
00:50:57,621 --> 00:50:59,456
then maybe the y
combinator would be useful,

854
00:50:59,456 --> 00:51:01,458
but I don't really recommend that.

855
00:51:02,026 --> 00:51:04,962
What I found interesting
though is by starting with some

856
00:51:04,962 --> 00:51:08,367
very basic principles and
applying these refactorings,

857
00:51:08,367 --> 00:51:11,469
I found the functional refactorings
to be very fascinating.

858
00:51:11,469 --> 00:51:14,338
By applying that you can
take something in one shape

859
00:51:14,338 --> 00:51:17,107
and transform it and get
it into a different shape

860
00:51:17,107 --> 00:51:19,944
that's more appropriate for
the needs that you have.

861
00:51:19,944 --> 00:51:21,812
I really enjoyed playing around with

862
00:51:21,812 --> 00:51:26,083
those refactorings in that exercise.

863
00:51:26,317 --> 00:51:28,853
Now you can go home and you can explain to

864
00:51:28,853 --> 00:51:32,856
all your coworkers that you've seen the

865
00:51:32,856 --> 00:51:35,359
y combinator, you
understand how it's done.

866
00:51:37,141 --> 00:51:38,696
I think the y combinator is one of those

867
00:51:38,696 --> 00:51:41,798
examples of great beauty in mathematics.

868
00:51:41,799 --> 00:51:44,572
It's a really interesting function that is

869
00:51:44,572 --> 00:51:48,205
theoretical in a lot of
respects, but comes out

870
00:51:48,205 --> 00:51:50,407
of something like lambda
calculus which seems

871
00:51:50,407 --> 00:51:54,778
a trivial macro replacement
type of language,

872
00:51:54,778 --> 00:51:59,286
but yet lambda calculus is
buried so deep into Ruby,

873
00:51:59,286 --> 00:52:02,320
we use it all the time
without even realizing it.

874
00:52:02,320 --> 00:52:05,956
It's one of those things that
have a great and profound impact.

875
00:52:05,957 --> 00:52:08,625
That's one of the the things
I really enjoyed researching

876
00:52:08,625 --> 00:52:11,862
this particular topic, and I
hope you guys enjoyed it as well.

877
00:52:11,929 --> 00:52:15,966
If you liked this, I'm going
to recommend a talk called

878
00:52:15,966 --> 00:52:18,702
Programming with Nothing by Tom Stuart.

879
00:52:18,702 --> 00:52:23,140
Tom uses nothing but
lambdas, the stabby procs,

880
00:52:23,140 --> 00:52:27,945
and calling thereof, and writes
the fizzbuzz application.

881
00:52:27,979 --> 00:52:31,249
He uses no integers, no strings, no logic,

882
00:52:31,249 --> 00:52:34,685
anything except calling lambda functions.

883
00:52:34,685 --> 00:52:38,923
It's a true example of
lambda calculus done in Ruby.

884
00:52:40,492 --> 00:52:42,159
Just Google programming with nothing and

885
00:52:42,159 --> 00:52:44,694
you'll turn up that video.
I recommend that one.

886
00:52:44,762 --> 00:52:46,731
Thank you very much, you
guys have a good day.

887
00:52:46,999 --> 00:52:50,000
(applause)

888
00:52:50,301 --> 00:52:54,871
(energetic music)

